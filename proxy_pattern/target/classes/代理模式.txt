1.什么是代理模式？
为其他对象提供一种代理以控制这个对象的访问
2.为什么要使用代理模式?
①中介隔离：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理对象可以在客户类与委托对象之间起到中介作用，其特征是代理类和委托类实现相同接口
②开闭原则，增加功能：代理类除了是客户类和委托类之间的中介之外，我们还可以通过代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要
再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身不是真正实现服务
而是通过调用委托类的相关方法，来提供特定的服务。真正的业务功能本身还是由委托类来实现的，但是可以在业务功能执行前后加入一些公共的服务。列如：
我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类.
3.代理模式的实现原理
代理模式主要包含三个角色：即抽象主题角色、委托角色（被代理角色，Proxied）、以及代理类角色（Proxy）
抽象主题角色：可以使接口也可以是抽象类
委托类角色：真实主题角色，业务逻辑的具体执行者
代理类角色：内部含有对真实对象RealSubject的引用，负责对真实主题角色的调用，并在真实主题角色处理前后做预处理和后处理
4.代理模式应用场景
SpringAop、日志收集、权限控制、过滤器、RPC远程调用
5.动态代理
jdk动态代理：
①创建被代理的接口和类
②实现InvocationHandler接口，对目标接口中声明的所有方法进行统一处理
③调用Proxy的静态方法，创建代理类并生成相应的代理对象；
cglib动态代理
    1.cglib是一个强大的，高性能，高质量的代码生成类库。它可以在运行期扩展JAVA类与实现JAVA接口。其底层实现是通过ASM字节码处理框架来转换字节码并生成新的类。大部分功能实际上是ASM所提供的，Cglib只是封装了ASM，简化了ASM操作，实现了运行期生成新的class。
    2.cglib的原理：
        运行时动态的生成一个被代理类的子类（通过ASM字节码处理框架实现），子类重写了被代理类中所有非final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势植入横切逻辑。
    3.Cglib优缺点
        优点：JDK动态代理要求被代理的类必须实现接口，当需要代理的类没有实现接口时Cglib代理是一个很好的选择。另一个优点是Cglib动态代理比使用java反射的JDK动态代理要快
        缺点：对于被代理类中的final方法，无法进行代理，因为子类中无法重写final函数
    4.cglib代理的实现
        实现MethodInterceptor接口的intercept方法后，所有生成的代理方法都调用这个方法。
        intercept方法的具体参数有
        obj 目标类的实例
        1.	method 目标方法实例（通过反射获取的目标方法实例）
        2.	args 目标方法的参数
        3.	proxy 代理类的实例
        该方法的返回值就是目标方法的返回值。
6.静态代理与动态代理区别
    静态代理需要自己写代理类，而动态代理不需要写代理类。
7.JDK动态代理与CGLIB实现区别
    JDK动态代理底层实现:
        JDK的动态代理使用Java的反射技术生成动态代理类，只能代理实现了接口的类， 没有实现接口的类不能实现动态代理。
    CGLIB动态代理底层实现:
        运行时动态的生成一个被代理类的子类（通过ASM字节码处理框架实现），子类重写了被代理类中所有非final的方法，在子类中采用方法拦截的技术拦截所有父类方法的调用，不需要被代理类对象实现接口，从而CGLIB动态代理效率比Jdk动态代理反射技术效率要高。


8.纯手写动态代理模式原理思路
    1.使用java语言组装$Proxy0.java的源码，使用java的反射机制获取目标对象的接口的所有方法（使用反射机制）
        *.java编译成.class文件
    2.将$Proxy0.java文件编译成$Proxy0.class文件（java compile 的api）
    3.使用classloader将class文件加载到JVM内存中
        ClassLoader 顾名思义就是类加载器,ClassLoader 作用：
        负责将 Class 加载到 JVM 中
        审查每个类由谁加载（父优先的等级加载机制）
        将 Class 字节码重新解析成 JVM 统一要求的对象格式
